apply plugin: "de.undercouch.download"
apply plugin: "ch.so.agi.gretl"

import ch.so.agi.gretl.api.TransferSet
import ch.so.agi.gretl.tasks.*
import java.nio.file.Paths
import java.nio.file.Files
import de.undercouch.gradle.tasks.download.Download


ext {
    pathToTempFolder = System.getProperty("java.io.tmpdir")
    pathToPdfExportFolder = Files.createTempDirectory("oerebadaeinzelschutz-").toFile().getAbsolutePath()

    iliModelVorschriften = "OeREBKRMvs_V1_1"
    iliModelTransferstruktur = "OeREBKRMtrsfr_V1_1"

    symbolsWmsBaseUrl = "https://" + geoservicesHostName

    dbSchemaEinzelschutzOereb = "ada_denkmalschutz_oereb"
    einzelschutzDenkmalDataSet = "ch.so.ada.denkmalschutz"
    
    xtfFileName = einzelschutzDenkmalDataSet + ".oereb.xtf"
    zipFileName = einzelschutzDenkmalDataSet + ".oereb_xtf.zip"

    federalLegalBasisBaseUrl = "http://models.geo.admin.ch/V_D/OeREB/"
    federalLegalBaseDataSet = "OeREBKRM_V1_1_Gesetze_20180501"

    cantonalLegalBasisBaseUrl = "https://geo.so.ch/geodata/ch.so.sk.gesetze.oereb/"
    cantonalLegalBaseDataSet = "ch.so.sk.gesetze"

    responsibleOfficesBaseUrl = "https://geo.so.ch/geodata/ch.so.agi.zustaendigestellen.oereb/"
    responsibleOfficesDataSet = "ch.so.agi.zustaendigestellen"

    wmsLayerList = [
        ["ch.SO.Einzelschutz.Punkt", "urn:fdc:ilismeta.interlis.ch:2019:Typ_geschuetztes_historisches_Kulturdenkmal_Punkt"],
        ["ch.SO.Einzelschutz.Flaeche", "urn:fdc:ilismeta.interlis.ch:2019:Typ_geschuetztes_historisches_Kulturdenkmal_Flaeche"]
    ]

    bucketSuffix = '-undefined'
    if ( gretlEnvironment == 'production' ) {
        bucketSuffix = ''
    } else if ( gretlEnvironment == 'integration' || gretlEnvironment == 'development' ) {
        bucketSuffix = '-' + gretlEnvironment.substring(0, 3)
    } else {
        bucketSuffix = '-' + gretlEnvironment
    }
    
    s3AdaStageBucket = "ch.so.ada.denkmal-stage$bucketSuffix"
    s3AdaLiveBucket = "ch.so.ada.denkmal$bucketSuffix"

    s3AgiTargetBucket = "ch.so.agi.geodata$bucketSuffix"
}


task downloadFederalLegalBasis(type: Download, dependsOn: 'deleteFromOereb') {
    description = "Download Bundesgesetze ($federalLegalBaseDataSet)."
    src federalLegalBasisBaseUrl + federalLegalBaseDataSet + ".xml"
    dest pathToTempFolder
    overwrite true      
}

task importFederalLegalBasisToOereb(type: Ili2pgReplace, dependsOn: 'downloadFederalLegalBasis') {
    description = "Import Bundesgesetze ($federalLegalBaseDataSet)."
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    models = iliModelVorschriften
    dbschema = dbSchemaEinzelschutzOereb
    dataFile = file(Paths.get(pathToTempFolder.toString(), federalLegalBaseDataSet + ".xml"))
    dataset = "ch.admin.bk.gesetze" 
}

task downloadCantonalLegalBasis(type: Download, dependsOn: 'deleteFromOereb') {
    description = "Download kantonale Gesetze ($cantonalLegalBaseDataSet)."
    src cantonalLegalBasisBaseUrl + cantonalLegalBaseDataSet + ".xtf"
    dest pathToTempFolder
    overwrite true    
}

task importCantonalLegalBasisToOereb(type: Ili2pgReplace, dependsOn: 'downloadCantonalLegalBasis') {
    description = "Import kantonale Gesetze ($cantonalLegalBaseDataSet)."
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    models = iliModelVorschriften
    dbschema = dbSchemaEinzelschutzOereb
    dataFile = file(Paths.get(pathToTempFolder.toString(), cantonalLegalBaseDataSet + ".xtf"))
    dataset = cantonalLegalBaseDataSet 
}

task downloadResponsibleOffices(type: Download, dependsOn: 'deleteFromOereb') {
    description = "Download zuständige Stellen ($responsibleOfficesDataSet)."
    src responsibleOfficesBaseUrl + responsibleOfficesDataSet + ".xtf"
    dest pathToTempFolder
    overwrite true       
}

task importResponsibleOfficesToOereb(type: Ili2pgReplace, dependsOn: 'downloadResponsibleOffices') {
    description = "Importafu zuständige Stellen ($responsibleOfficesDataSet)."
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    models = iliModelTransferstruktur
    dbschema = dbSchemaEinzelschutzOereb
    dataFile = file(Paths.get(pathToTempFolder.toString(), responsibleOfficesDataSet + ".xtf"))
    dataset = einzelschutzDenkmalDataSet
}

task deleteFromOereb(type: SqlExecutor) {
    description = "Löscht die Daten aus dem Transferschema."
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    sqlFiles = ["delete_oereb_einzelschutz_denkmal_tables.sql"]
}

task transferData(type: SqlExecutor, dependsOn: ["importFederalLegalBasisToOereb", "importCantonalLegalBasisToOereb", "importResponsibleOfficesToOereb"]) {
    description = "Führt den Datenumbau in das Transferschema durch."
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    sqlParameters = [s3AdaLiveBucket: "'" + s3AdaLiveBucket + "'"]
    sqlFiles = ["insert_oereb_einzelschutz_denkmal_tables.sql"]
}

wmsLayerList.each { wmsLayer ->
    def wmsLayerName = wmsLayer.getAt(0)
    def typeCodeList = wmsLayer.getAt(1)
    task "updateSymbols_$wmsLayerName"(type: OerebIconizerQgis3) {
        description = "Erzeugt die Symbole für die einzelnen Legendeneinträge für $wmsLayerName."
        sldUrl = "$symbolsWmsBaseUrl/wms/oereb-symbols?&SERVICE=WMS&REQUEST=GetStyles&LAYERS=$wmsLayerName&SLD_VERSION=1.1.0"
        legendGraphicUrl = "$symbolsWmsBaseUrl/wms/oereb-symbols?SERVICE=WMS&REQUEST=GetLegendGraphic&LAYER=$wmsLayerName&FORMAT=image/png&RULELABEL=false&LAYERTITLE=false&HEIGHT=35&WIDTH=70&SYMBOLHEIGHT=3&SYMBOLWIDTH=6&DPI=300"
        database = [dbUriEdit, dbUserEdit, dbPwdEdit]
        dbQTable = "ada_denkmalschutz_oereb.transferstruktur_legendeeintrag"
        typeCodeAttrName = "artcode"
        typeCodeListAttrName = "artcodeliste"
        typeCodeListValue = typeCodeList
        symbolAttrName = "symbol"
        useCommunalTypeCodes = false
    }
}

task updateSymbols(dependsOn: "transferData") {
    description = "Aggregationstask für das Updaten der Symbole."
    dependsOn {
        tasks.findAll { task -> task.name.startsWith('updateSymbols_') }
    }
}

task exportData(type: Ili2pgExport, dependsOn: "updateSymbols") {
    description = "Exportiert die umgebauten Daten aus dem Transferschema in ein INTERLIS-Datei."
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    models = iliModelTransferstruktur
    dbschema = dbSchemaEinzelschutzOereb
    dataFile = file(Paths.get("$rootDir", xtfFileName))
    dataset = einzelschutzDenkmalDataSet
    disableValidation = true
}

task replaceWmsServer(dependsOn: "exportData") {
    description = "Ersetzt verschiedene Elemente (Host, Pfad, etc.) der WMS-Requests (GetMap und GetLegendGraphic)."
    doLast {
        ant.replace(
        file: file(Paths.get("$rootDir", xtfFileName)),
        token: '${wmsHost}',
        value: 'https://' + geoservicesHostName,
        encoding: 'UTF-8')
    }
}

task exportPdfFromDatabase(type: DatabaseDocumentExport, dependsOn: "replaceWmsServer") {
    description = "PDF aus Datenbank exportieren."
    database = [dbUriEdit, dbUserEdit, dbPwdEdit]
    qualifiedTableName = "ada_denkmalschutz.fachapplikation_rechtsvorschrift_link"
    documentColumn = "multimedia_link"
    targetDir = file(pathToPdfExportFolder)
    fileNamePrefix = "ada_"
    fileNameExtension = "pdf"
}

task uploadPdfToS3Stage(type: S3Upload, dependsOn: "exportPdfFromDatabase") {
    description = "PDF aus Verzeichnis nach S3 hochladen."
    accessKey = awsAccessKeyAda
    secretKey = awsSecretAccessKeyAda
    sourceDir = file(pathToPdfExportFolder)
    endPoint = "https://s3.amazonaws.com/"
    region = "eu-central-1"
    bucketName = s3AdaStageBucket
    acl = "PublicRead"
}

task validateData(type: IliValidator, dependsOn: "uploadPdfToS3Stage") {
    description = "Validiert die exportierten Daten in der Transferstruktur inkl. der externen Beziehungen."
    dataFiles = [
                 file(Paths.get(pathToTempFolder.toString(), federalLegalBaseDataSet + ".xml")), 
                 file(Paths.get(pathToTempFolder.toString(), cantonalLegalBaseDataSet + ".xtf")), 
                 file(Paths.get("$rootDir", xtfFileName))
                ]
    allObjectsAccessible = true
}

task importDataToStage(type: Ili2pgReplace, dependsOn: "validateData") {
    description = "Import des Einzelschutz-ÖREB-Datensatz in das Stage-Schema."
    database = [dbUriOereb, dbUserOereb, dbPwdOereb]
    models = iliModelTransferstruktur
    dbschema = "stage"
    dataFile = file(Paths.get("$rootDir", xtfFileName))
    dataset = einzelschutzDenkmalDataSet
    finalizedBy {
        updateS3StageLink
    }
}

task updateS3StageLink(type: SqlExecutor) {
    description = "Setzt den Link der Pdfs auf die Stage-Umbebung"
    database = [dbUriOereb, dbUserOereb, dbPwdOereb]
    sqlFiles = ["update_oerebkrm_v1_1_localiseduri_table.sql"]
}

task refreshOerebWMSTablesStage(type: SqlExecutor) {
    description = "Aktualisiert OEREB WMS Tabellen."
    database = [dbUriOereb, dbUserOereb, dbPwdOereb]
    sqlFiles = ["update_oerebwms_einzelschutz_denkmal_tables.sql"]
    sqlParameters = [dbSchema: 'stage']
}



task copyPdfToS3Live(type: S3Bucket2Bucket) {
    accessKey = awsAccessKeyAda
    secretKey = awsSecretAccessKeyAda
    sourceBucket = s3AdaStageBucket
    targetBucket = s3AdaLiveBucket
}

task importDataToLive(type: Ili2pgReplace, dependsOn: "copyPdfToS3Live") {
    description = "Import des Einzelschutz-ÖREB-Datensatz in das Live-Schema."
    database = [dbUriOereb, dbUserOereb, dbPwdOereb]
    models = iliModelTransferstruktur
    dbschema = "live"
    dataFile = file(Paths.get("$rootDir", xtfFileName))
    dataset = einzelschutzDenkmalDataSet 
}

task refreshOerebWMSTablesLive(type: SqlExecutor) {
    description = "Aktualisiert OEREB WMS Tabellen."
    database = [dbUriOereb, dbUserOereb, dbPwdOereb]
    sqlFiles = ["update_oerebwms_einzelschutz_denkmal_tables.sql"]
    sqlParameters = [dbSchema: 'live']
}


task zipXtfFile(type: Zip) {
    description = "Zipt das xtf-File mit den Einzelschutz-Denkmal-Daten für den Upload nach S3"
    from "$rootDir"
    include xtfFileName
    archiveName zipFileName
    destinationDir(file("$rootDir"))
}

task uploadXtfToS3Geodata(type: S3Upload, dependsOn: "zipXtfFile") {
    description = "Xtf-File nach S3 hochladen."
    accessKey = awsAccessKeyAgi
    secretKey = awsSecretAccessKeyAgi
    sourceFile = file(Paths.get("$rootDir", zipFileName))
    endPoint = "https://s3.amazonaws.com/"
    region = "eu-central-1"
    bucketName = s3AgiTargetBucket
    acl = "PublicRead"
}
